# Source Code TODOs

Question, Line -> Fix those widgets or they work?

During commits of May 28, for some reason Layouts (maybe other widgets?) don't behave as they did.
Specifically for Layouts, Layouts now need width/height where previously this wasn't needed.
(Maybe screen's append function doesn't do all it should?)

In Widget, @window property is non-nil. If parent is specified, @window gets set to that of the
parent. If window is specified, it gets set to that. And if window is not specified, the global/
default window is half-assigned (child thinks that's its window, but window doesn't have that
child in its list of children, because Window#append was not called). This situation is, at the
moment, necessary for the current code to work, because many lookups from children into @window
are made, and also they must NOT exist as children of @window (only top-level, immediate children
should be in @window's.children list). This should be fixed such that @window becomes nilable and
all logic everywhere is adjusted accordingly.

Currently it seems possible to append a widget to multiple parents. This produces an inconsistent
state in which all parents keep a reference to the child widget, while the child widget thinks
it belongs to the last/most-recently added parent. Check if this is the case, and/or fix whatever
issues may be revealed while testing this.

In test/widget-valign.cr, the content of the widget is displayed twice. Determine why and fix.
Also in the Hello, World example, if using valign, the rendering is incorrect.

In the code, questions and/or things to verify at some later point are identified with "XXX".

Things to change/improve are identified with "TODO".

src/app/tput.cr -> review everything
src/namespace.cr -> cleanup some definitions
src/app.cr -> avoid use of Term::Screen, and make sure to check the size of @output, not STDOUT
src/event.cr -> add descriptions of all events

src/widget/overlayimage.cr -> is that OK or more work needs to be done?
src/widget/bigtext.cr -> is that OK or more work needs to be done?
src/widget/question.cr -> needs more work

# List of TODOs in no particular order

auto_padding is here defined on Window (equivalent of Blessed's Screen). Is it defined in Blessed in
its Screen too, or it belongs to a different place? (Like, why would auto-padding be on a window
level, instead of e.g. Screen or global? This would remove some conditional testing whether @window
is defined.)

Currently, when a Screen is listening for keyboard, it does this keypress by keypress. See how this affects
pasting blocks of text into the terminal via mouse. Maybe they could be a "batch" mode where, if a paste
is detected (possibly by realizing that multiple bytes became available at the same time?), all this
text is processed as a plain text, at once? Maybe with a flag/toggle to do so?

Currently events are emitted whereever needed with just e.g.: `emit SomeEvent, ...`.
See if this is OK, or if events to emit should be passed via a channel and always be emitted from a single/same Fiber.

Examine effect of `use_buffer` variable in Tput, and see whether it can be completely removed, or it can be used
meaningfully in some way?

There is a concept of Unicode and "full Unicode". Full being the one with all Unicode stuff that Crystal currently 
does not support outside of its UTF-8 support. See what to do this over time - is there a chance Crystal would
support more, or the idea of "full Unicode" needs to be just dropped from the sources.

On an element, top/left/width/height can also be a string. Also allow Symbols to be used.

Currently, every widget must have a `Screen`. This should not be so. See what try()s have to be added to allow
`screen` of a widget to remain uninitialized. (Such widgets would simply never be rendered since they're not
on any screen, but it should otherwise be possible to create a hierarchy of widgets in memory.)
But, don't bother if this only if doing it would be too inconvenient (e.g. if even basic functions require
values that are only known after a Screen is associated.)

Screen is currently autocreated if not created explicitly. See if it would make sense to move to a model where
a Screen needs to be created explicitly. This could make sense because creating a Screen, just like in blessed,
automatically activates it and switches to alternate buffer. Maybe not everyone wants that, depending on the type
of app.

See if an option could be added to control whether a Screen will use alternate buffer or not.

See if it would make sense to name/rename all EventHandler events in such a way that the name identifies whether
the action is about to happen, or has happened. In that case, e.g. Event::Render would mean the event has been
triggered before the actual action, and Event::Rendered would mean it was triggered after.

See if it would be of any benefit to mark certain methods with @[AlwaysInline].

Make sure that the background character for a cell is always configurable and never literally taken to be ' '.
This will allow someone to completely change what the background char is. I guess this has already been done
to a good extent, but verifying/confirming it would be good.

When specifying top/left, it is possible to say "center". This will center the widget, and is different than
saying "50%". For example, for a screen of 100 and width 50, "center" will make it begin at 25, while "50%" will
make it begin at 50. Now, when using percentages, it is possible to say e.g. "50%+10" (This would result in
widget starting at 60 in our example). But it appears it is not possible to use the +- specifier if "center"
is used. Support specifying +- in all cases.

TextArea widget has an attribute input_on_focus=Bool. By default it is false, and in turn requires Enter to be
pressed for the widget to start accepting input. But setting it to true, so that input would be accepted as soon
as / whenever the widget is in focus, does not work correctly and needs fixing.

In test/widget-padding.cr and test/widget-bigtext.cr, those test differs from blessed in the background color of
the border. Find this exact code and make it identical.

In Crysterm, which should aim to be fully OO & clean code, strings have been replaced with enum values in many
places. However, when specifying widget sizes or position, percentages are still typically given with strings,
e.g. "80%", top/left support a special string value of "center", and width/height support "resizable". Strings
can stay as a supported option (for convenience of loading settings from text files, etc.?), but see if those
can be replaced with enums or similar, and with things like 80.percent() or something.

Fix screen.destroy() so that it does the same as in Blessed (destroy screen, reset term, exit).

For good OO, and like in Qt, it would be good if all functions that deal with Points, Sizes, and Dimensions,
would also accept those specific classes/structs that we'd define, rather than just numbers/Ints. This already
exists to an extent, e.g. in Tput there is class Size, Point, etc. These should be used more throughout the
codebase, and any other relevant new ones added.

See if it would make sense to actually put everything from Crysterm::Widget::Element class into Crysterm::Widget.
Logically it could make sense, since Element is just base/abstract Widget? Also, on a related note, see if Node
should be moved out of Widget, and also whether Screen should be moved out of Widget, since it only inherits
from Node, not Widget.

Would anything be gained by using a Set instead of an Array as the containing element for individuall Cell's
which represent all chars/cells on the screen?

Blessed recognizes a concept of Unicode and Full Unicode. I guess Unicode is what Crystal currently supports.
How to deal with the whole other side of things (Full Unicode)? Implement if possible.

Some elements of Style should have defaults. See whether it makes sense, as an example, for @style.bar to
fallback to @style if `bar` specifically isn't styled. Or, if this produces undesirable results, see if `bar`
can have a default, possibly calculated in-place to always be distinctive (if needed) from the main style
by running a method to pick a color of different value.
Or, maybe the whole thing needs to be replaced by a fully general Style that can actually act as an App
theme, with all the functions/fallback for that embedded in the class.

Speaking of Style, some things, like Style#border, and Border class, are not in sync. Maybe Border class
is completely unused and should be fixed / sorted out?

The positioning of widgets, with Position, Pos, LPos, and so on, at the moment works, but there
are certainly some unused variables, and/or there might be some methods within those that do not
work. Review the whole thing for final trimming & verification.
